package io.youi.util

import io.circe.parser._
import java.io.File

import io.circe.Json
import org.powerscala.io._
import profig.JsonUtil

object SwaggerClientBuilder {
  def main(args: Array[String]): Unit = {
    val file = new File("swagger.json")
    val json = parse(IO.stream(file, new StringBuilder).toString).getOrElse(throw new RuntimeException("Failed to parse!"))
    val directory = new File("utilities/src/main/scala/")
    val b = new SwaggerClientBuilder(directory, "com.outr.arango.api", json)
//    b.createClasses()
    b.test()
  }
}

class SwaggerClientBuilder(directory: File, packageName: String, swagger: Json) {
  private val SnakeSplitter = "_?([a-zA-Z0-9]+)".r
  private val NameSplitter = "[-._ ]([a-zA-Z0-9])".r

  private val WordSwap = Map(
    "api" -> "API"
  )
  private val NameSwap = Map(
    "type" -> "`type`",
    "new" -> "`new`",
    "Json Request Body" -> "body"
  )
  private val TypeSwap = Map(
    "boolean" -> "Boolean",
    "booleanboolean" -> "Boolean",
    "integer" -> "Int",
    "integerinteger" -> "Int",
    "integerint64" -> "Long",
    "integeruint64" -> "Long",
    "number" -> "Double",
    "numberfloat" -> "Double",
    "string" -> "String",
    "array" -> "List[String]",
    "arraystring" -> "List[String]",
    "arrayinteger" -> "List[Int]",
    "object" -> "io.circe.Json",
    "arrayobject" -> "List[io.circe.Json]"
  )
  private val basePath = (swagger \\ "basePath").head.asString.get
  private val definitions = (swagger \\ "definitions").head.asObject.get
  private val paths = (swagger \\ "paths").head

  private val packageDirectory: File = new File(directory, packageName.replace('.', '/'))

  def test(): Unit = {
    val path = "/_api/collection"
    val method = "post"
    val json = ((paths \\ path).head \\ method).head
    createEndPoint(path, method, json)
  }

  def createEndPoint(path: String, method: String, json: Json): Unit = {
    val description = (json \\ "description").head.asString.getOrElse("").trim
    val parameters = (json \\ "parameters").headOption.flatMap(_.asArray.map(_.toList)).getOrElse(Nil).map { j =>
      JsonUtil.fromJson[Parameter](j)
    }
    val args = parameters.map { p =>
      val n = fixName(p.name)
      val t = p.`type` match {
        case Some(v) => v
        case None => {
          val s = p.schema.getOrElse(throw new RuntimeException(s"No type or schema for $p"))
          val refName = s.`$ref`.substring(s.`$ref`.lastIndexOf('/') + 1)
          className(refName)
        }
      }
      val `type` = generateType(n, t, p.format, p.`type`.nonEmpty, p.required)
      s"$n: ${`type`}"
    }
    scribe.info(s"Args: $args")
  }

  def createClasses(): List[String] = {
    // "post_api_collection_opts"
    definitions.toList.map {
      case (n, j) => {
        packageDirectory.mkdirs()
        val clazz = className(n)
        val source = createClass(clazz, j)
        val file = new File(packageDirectory, s"$clazz.scala")
        IO.stream(source, file)
        s"$packageName.$clazz"
      }
    }
  }

  def createClass(clazz: String, json: Json): String = {
    val required = (json \\ "required").headOption.map(_.asArray.get.flatMap(_.asString).toSet).getOrElse(Set.empty)
    val properties = (json \\ "properties").headOption.flatMap(_.asObject.map(_.toList)).getOrElse(Nil).map {
      case (n, j) => {
        (j \\ "$ref").headOption.flatMap(_.asString) match {
          case Some(ref) => {
            val refName = ref.substring(ref.lastIndexOf('/') + 1)
            Property(n, "", None, className(refName), required.contains(n), builtIn = false)
          }
          case None => {
            JsonUtil.fromJson[Property](j).copy(name = n, required = required.contains(n))
          }
        }
      }
    }.sortBy(!_.required)
    val pre = s"case class $clazz("
    val spacer = pre.replaceAll(".", " ")
    val params = properties.map(paramFrom)
    s"""package $packageName
       |
       |/**
       |  * $clazz
       |  *
       |  * ${properties.map(p => s"@param ${p.name} ${p.description.trim}").mkString("\n  * ")}
       |  *
       |  * WARNING: This code is generated by youi-plugin's generateHttpClient. Do not modify directly.
       |  */
       |case class $clazz(${params.mkString(s",\n$spacer")})
     """.stripMargin.trim
  }

  def className(name: String): String = SnakeSplitter.replaceAllIn(name, m => {
    val value = m.group(1)
    WordSwap.getOrElse(value, value.capitalize)
  })

  def fixName(name: String): String = {
    NameSplitter.replaceAllIn(NameSwap.getOrElse(name, name), m => {
      m.group(1).toUpperCase
    }).replaceAll("[\\[\\]*]", "")
  }

  def generateType(name: String, `type`: String, format: Option[String], builtIn: Boolean, required: Boolean): String = {
    val merged = s"${`type`}${format.getOrElse("")}"
    val t = if (builtIn) {
      TypeSwap.getOrElse(merged, throw new RuntimeException(s"Unsupported type: [$merged] for $name"))
    } else {
      `type`
    }
    if (required) {
      t
    } else {
      s"Option[$t] = None"
    }
  }

  def paramFrom(property: Property): String = {
    val name = fixName(property.name)
    val `type` = generateType(property.name, property.`type`, property.format, property.builtIn, property.required)
    s"$name: ${`type`}"
  }

  case class Property(name: String = "", description: String, format: Option[String], `type`: String, required: Boolean = false, builtIn: Boolean = true)

  case class Parameter(in: String, name: String, required: Boolean, schema: Option[Schema], description: Option[String], `type`: Option[String], format: Option[String])

  case class Schema(`$ref`: String)
}